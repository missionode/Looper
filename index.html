<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Looper v6 - Toggle Collapse Animation</title>
<style>
    body {
        margin: 0;
        font-family: Arial, sans-serif;
        background: radial-gradient(circle at center, #0a0a0a, #000000);
        color: #fff;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        min-height: 100vh;
        text-align: center;
        padding-top: 40px;
    }
    .logo { font-size: 4rem; margin-bottom: 10px; color: #00d9ff; }
    h1 { font-size: 3rem; margin: 0; }
    h3 { font-size: 1.5rem; color: #aaaaaa; margin: 5px 0 20px; }
    p { max-width: 500px; font-size: 1.1rem; color: #cccccc; }
    ul { list-style: none; padding: 0; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; }
    ul li a { text-decoration: none; color: #00d9ff; font-weight: bold; transition: color 0.3s; }
    ul li a:hover { color: #00aacc; }
    .features ul { flex-direction: column; align-items: center; }
    button {
        background: #00d9ff; border: none; padding: 10px 20px; font-size: 1rem;
        margin-top: 20px; cursor: pointer; border-radius: 5px; color: #000;
        transition: background 0.3s;
    }
    button:hover { background: #00aacc; }
    input {
        padding: 8px;
        border-radius: 5px;
        border: none;
        margin-top: 10px;
        font-size: 1rem;
        text-align: center;
    }
    [data-template] { opacity: 1; transition: opacity 0.3s ease-in-out; }
    [data-template].fade-out { opacity: 0; }

    /* Collapse animation */
    .collapsible {
        overflow: hidden;
        max-height: 0;
        transition: max-height 0.4s ease-out, opacity 0.4s ease-out;
        opacity: 0;
    }
    .collapsible.open {
        max-height: 500px;
        opacity: 1;
    }
</style>
</head>
<body>

<script>
const Looper = {
    context: {},
    templates: {},
    domRefs: {},
    varMap: {},
    events: {},
    lastData: "",

    escapeHTML(str) {
        return String(str)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    },

    preload(templates, vars, events = {}) {
        this.templates = templates;
        this.context = vars;
        this.domRefs = {};
        this.events = events;
        this.varMap = {};

        for (let key in templates) {
            let matches = templates[key].match(/\$\.(\w+)/g) || [];
            matches.forEach(m => {
                let varName = m.slice(2);
                if (!this.varMap[varName]) this.varMap[varName] = [];
                this.varMap[varName].push(key);
            });
        }
    },

    render(root = document.body) {
        root.innerHTML = "";
        for (let key in this.templates) {
            let html = this.parseTemplate(this.templates[key]);
            let wrapper = document.createElement("div");
            wrapper.setAttribute("data-template", key);
            wrapper.innerHTML = html;
            root.appendChild(wrapper);
            this.domRefs[key] = wrapper;
        }
        this.bindEvents();
        this.bindInputs();

        // Set collapse initial state
        const wrap = document.getElementById("featuresWrap");
        if (wrap && this.context.showFeatures) wrap.classList.add("open");
    },

    rerender(changes) {
        Object.assign(this.context, changes);
        let affectedTemplates = new Set();
        for (let varName in changes) {
            if (this.varMap[varName]) {
                this.varMap[varName].forEach(tKey => affectedTemplates.add(tKey));
            }
        }
        affectedTemplates.forEach(tKey => {
            let el = this.domRefs[tKey];
            el.classList.add("fade-out");
            setTimeout(() => {
                el.innerHTML = this.parseTemplate(this.templates[tKey]);
                el.classList.remove("fade-out");
                this.bindEvents();
                this.bindInputs();

                // Keep animation state after re-render
                if (tKey === "body") {
                    const wrap = document.getElementById("featuresWrap");
                    if (wrap && this.context.showFeatures) wrap.classList.add("open");
                }
            }, 300);
        });
    },

    parseTemplate(template) {
        template = template.replace(/\{\{if ([^}]+)\}\}([\s\S]*?)\{\{else\}\}([\s\S]*?)\{\{end\}\}/g,
            (_, condition, truePart, falsePart) => {
                return this.evalCondition(condition) ? truePart : falsePart;
            });
        template = template.replace(/\{\{if ([^}]+)\}\}([\s\S]*?)\{\{end\}\}/g,
            (_, condition, truePart) => {
                return this.evalCondition(condition) ? truePart : "";
            });

        template = template.replace(/\{\{(\w+)\}\}/g, (_, compName) => {
            return this.templates[compName] ? this.parseTemplate(this.templates[compName]) : "";
        });

        template = template.replace(/\$\.(\w+)\[(.*?)\]/gs, (_, arrName, loopTpl) => {
            let arr = this.context[arrName];
            if (!Array.isArray(arr)) return "";
            return arr.map(item => {
                return loopTpl.replace(/\$\.(\w+)/g, (_, v) => {
                    let val = item[v];
                    return this.isSafeHTML(val) ? val.slice(8) : this.escapeHTML(val);
                });
            }).join("");
        });

        template = template.replace(/\$\.(\w+)/g, (_, v) => {
            let val = this.context[v];
            return this.isSafeHTML(val) ? val.slice(8) : this.escapeHTML(val);
        });

        return template;
    },

    evalCondition(condition) {
        try {
            return Function("data", `with(data) { return ${condition}; }`)(this.context);
        } catch {
            return false;
        }
    },

    isSafeHTML(val) { return typeof val === "string" && val.startsWith("__HTML__"); },

    bindEvents() {
        document.querySelectorAll("[data-onclick]").forEach(el => {
            let fnName = el.getAttribute("data-onclick");
            if (typeof this.events[fnName] === "function") {
                el.onclick = this.events[fnName];
            }
        });
    },

    bindInputs() {
        document.querySelectorAll("[data-bind]").forEach(input => {
            let varName = input.getAttribute("data-bind");
            if (this.context[varName] !== undefined) {
                input.value = this.context[varName];
                input.addEventListener("input", e => {
                    this.context[varName] = e.target.value;
                    this.rerender({ [varName]: e.target.value });
                });
            }
        });
    },

    async loadFromJSON(url, pollInterval = 0) {
        const fetchData = async () => {
            try {
                const res = await fetch(url);
                const data = await res.json();
                const jsonStr = JSON.stringify(data);
                if (jsonStr !== this.lastData) {
                    this.lastData = jsonStr;
                    this.preload(data.templates, data.vars, this.events);
                    this.render();
                }
            } catch (e) {
                console.error("Looper JSON load error:", e);
            }
        };
        await fetchData();
        if (pollInterval > 0) setInterval(fetchData, pollInterval);
    }
};

Looper.events = {
    toggleFeatures: () => {
        const wrap = document.getElementById("featuresWrap");
        const isOpen = wrap.classList.contains("open");

        if (isOpen) {
            wrap.classList.remove("open");
            setTimeout(() => {
                Looper.rerender({ showFeatures: false });
            }, 400);
        } else {
            Looper.rerender({ showFeatures: true });
            setTimeout(() => {
                document.getElementById("featuresWrap").classList.add("open");
            }, 20);
        }
    }
};

Looper.loadFromJSON("site.json", 5000);
</script>

</body>
</html>
